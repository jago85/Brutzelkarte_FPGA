// ============================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// ----------------------------------------------------------------------------
// Copyright (c) 2006-2011 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED 
// ----------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS AUTO-GENERATED BY THE LATTICEMICO SYSTEM.
//
// Permission:
//
//      Lattice Semiconductor grants permission to use this code
//      pursuant to the terms of the Lattice Semiconductor Corporation
//      Open Source License Agreement.  
//
// Disclaimer:
//
//      Lattice Semiconductor provides no warranty regarding the use or
//      functionality of this code. It is the user's responsibility to
//      verify the user’s design for consistency and functionality through
//      the use of formal verification methods.
//
// ----------------------------------------------------------------------------
//
//                  Lattice Semiconductor Corporation
//                  5555 NE Moore Court
//                  Hillsboro, OR 97214
//                  U.S.A
//
//                  TEL: 1-800-Lattice (USA and Canada)
//                         503-286-8001 (other locations)
//
//                  web: http://www.latticesemi.com/
//                  email: techsupport@latticesemi.com
//
// ----------------------------------------------------------------------------
//                         FILE DETAILS
//
// Name			: lm8_top.v
// Project		: LatticeMico8
// Dependencies	: n/a
// Description	: LatticeMico8 microcontroller top level module.
// Revisions	: 3.2 (Initial version)
// 				: 3.3
//					- Removes issue that does incorrectly resets the core when 
//					  a reset occurs in the middle of an I/O (read/write) 
//					  operation.
// ============================================================================

module lm8
  #(
    parameter LATTICE_FAMILY            = "XO",
    parameter CFG_ROM_EN                = 0,
    parameter CFG_ROM_BASE_ADDRESS      = 32'h0,
    parameter I_CFG_XIP                 = 0,
    parameter CFG_PROM_INIT_FILE        = "none",
    parameter CFG_PROM_INIT_FILE_FORMAT = "hex",
    parameter CFG_PROM_SIZE             = 4096,            // PROM size (no. of instructions)
    parameter CFG_PROM_BASE_ADDRESS     = 32'h0,           // PROM Base Address
    parameter CFG_SP_INIT_FILE          = "none",
    parameter CFG_SP_INIT_FILE_FORMAT   = "binary",
    parameter SP_PORT_ENABLE            = 0,               // Internal Scratchpad
    parameter SP_SIZE                   = 256,             // Scratchpad size (no. of bytes)
    parameter SP_BASE_ADDRESS           = 32'h0,           // Scratchpad Base Address
    parameter CFG_IO_BASE_ADDRESS       = 32'h8000_0000,   // IO Base Address
    parameter CFG_EXT_SIZE_8            = 0,               // Page Pointer is 1 byte
    parameter CFG_EXT_SIZE_16           = 1,               // Page Pointer is 2 bytes
    parameter CFG_EXT_SIZE_32           = 0,               // Page Pointer is 3 bytes
    parameter CFG_REGISTER_16           = 1,               // 16 general-purpose registers
    parameter CFG_REGISTER_32           = 0,               // 32 general-purpose registers
    parameter CFG_EBR					= 0,			   // Use EBR for internal storage file
    parameter CFG_DISTRIBUTED_RAM       = 1,			   // Use distributed RAM for internal storage file
	parameter CFG_CALL_STACK_8          = 1,               // Call stack has 8 entries
    parameter CFG_CALL_STACK_16         = 0,               // Call stack has 16 entries
    parameter CFG_CALL_STACK_32         = 0,               // Call stack has 32 entries
    parameter INTERRUPTS                = 8                // Number of interrupts
    )
   (
    input clk_i,
    input rst_i,
    // Instruction WISHBONE Bus
    input I_ACK_I,
    input I_ERR_I,
    input I_RTY_I,
    input [7:0] I_DAT_I,
    output reg I_CYC_O,
    output reg I_STB_O,
    output reg [2:0] I_CTI_O,
    output reg [1:0] I_BTE_O,
    output reg I_WE_O,
    output reg I_SEL_O,
    output reg [7:0] I_DAT_O,
    output reg [31:0] I_ADR_O,
    output reg I_LOCK_O,
    // Data WISHBONE Bus
    input D_ACK_I,
    input D_ERR_I,
    input D_RTY_I,
    input [7:0] D_DAT_I,
    output reg D_CYC_O,
    output reg D_STB_O,
    output reg [2:0] D_CTI_O,
    output reg [1:0] D_BTE_O,
    output reg D_WE_O,
    output reg D_SEL_O,
    output reg [7:0] D_DAT_O,
    output reg [31:0] D_ADR_O,
    output reg D_LOCK_O,
    // Interrupt
    input [INTERRUPTS-1:0] interrupts
    );
   
   parameter CFG_EXT_SIZE = (CFG_EXT_SIZE_8 == 1) ? 8 : (CFG_EXT_SIZE_16 == 1) ? 16 : 32;
   parameter CFG_CALL_STACK = (CFG_CALL_STACK_8 == 1) ? 8 : (CFG_CALL_STACK_16 == 1) ? 16 : 32;
   
   localparam PROM_AW = clogb2(CFG_PROM_SIZE);
   localparam ALIGN_PROM_ROM_BASE = (32'hffff_ffff << PROM_AW) & CFG_ROM_BASE_ADDRESS;
   
   localparam SP_AW = clogb2(SP_SIZE);
   localparam ALIGN_SP_BASE = (SP_AW == 32) ? SP_BASE_ADDRESS : ((32'hffff_ffff << SP_AW) & SP_BASE_ADDRESS);
   localparam ALIGN_SP_ROM_BASE = CFG_ROM_BASE_ADDRESS + (CFG_PROM_SIZE*3);
   
   localparam ALIGN_IO_BASE = (CFG_EXT_SIZE == 32) ? CFG_IO_BASE_ADDRESS : ((32'hffff_ffff << CFG_EXT_SIZE) & CFG_IO_BASE_ADDRESS);
   
   localparam PGM_STACK_AW = clogb2(CFG_CALL_STACK);
   
   localparam INTERNAL_SP_CHECK = (SP_BASE_ADDRESS & ((1<<CFG_EXT_SIZE)-1)) >> SP_AW;
         
   wire [PROM_AW-1:0] prom_addr;
   wire [PROM_AW-1:0] pc;
   wire [17:0] 	      instr;
   wire 	      prom_enable;
   wire 	      prom_ready;
   wire [CFG_EXT_SIZE-1:0]  ext_addr;
   wire 	      ext_addr_cyc;
   wire [7:0] 	      ext_dout;
   wire 	      ext_mem_wr;
   wire 	      ext_mem_rd;
   wire 	      ext_io_wr;
   wire 	      ext_io_rd;
   wire [7:0] 	      ext_mem_din;
   wire [7:0] 	      ext_io_din;
   wire 	      ext_mem_ready;
   wire 	      intr_ack;
   wire 	      core_rst_n;

   /*----------------------------------------------------------------------
    
    
    Reset Synchronizer
    
    
    ----------------------------------------------------------------------*/
   wire 	      rst_i_n;
   reg 		      rff1;
   reg 		      rst_n;
   
   assign rst_i_n = ~rst_i;
   
   always @(posedge clk_i or negedge rst_i_n)
     if (!rst_i_n)
       {rst_n, rff1} <= 2'b00;
     else
       {rst_n, rff1} <= {rff1, 1'b1};
      
   
   /*----------------------------------------------------------------------
    
    
    Core
    
    
    ----------------------------------------------------------------------*/
   
   lm8_core
     #(
       .FAMILY_NAME                     (LATTICE_FAMILY),
       .EXT_AW                          (CFG_EXT_SIZE),
       .PROM_WB                         (I_CFG_XIP),
       .PROM_AW                         (PROM_AW),
       .PROM_AD                         (CFG_PROM_SIZE),
       .REGISTERS_16                    (CFG_REGISTER_16),
	   .REGISTER_EBR                    (CFG_EBR),
       .PGM_STACK_AW                    (PGM_STACK_AW),
       .PGM_STACK_AD                    (CFG_CALL_STACK),
       .INTERRUPTS                      (INTERRUPTS)
       ) u1_isp8_core
       (
	// Outputs
	.ext_addr			(ext_addr[CFG_EXT_SIZE-1:0]),
	.ext_addr_cyc			(ext_addr_cyc),
	.ext_dout			(ext_dout[7:0]),
	.ext_mem_wr			(ext_mem_wr),
	.ext_mem_rd			(ext_mem_rd),
	.ext_io_wr			(ext_io_wr),
	.ext_io_rd			(ext_io_rd),
	.intr_ack			(intr_ack),
	.prom_enable			(prom_enable),
	.prom_addr			(prom_addr[PROM_AW-1:0]),
	.pc				(pc[PROM_AW-1:0]),
	// Inputs
	.clk				(clk_i),
	.rst_n				(core_rst_n),
	.ext_mem_din			(ext_mem_din[7:0]),
	.ext_io_din			(ext_io_din[7:0]),
	.ext_mem_ready			(ext_mem_ready),
	.interrupts			(interrupts[INTERRUPTS-1:0]),
	.prom_ready			(prom_ready),
	.instr				(instr[17:0]));

   reg [PROM_AW-1+2:0] prom_waddr, prom_raddr;
   reg [17:0] 	       prom_wdata;
   reg 		       prom_wren, prom_rden;
   reg [SP_AW-1:0]     sp_waddr, sp_raddr;
   reg [7:0] 	       sp_wdata;
   reg 		       sp_wren, sp_wb_wren, sp_rden;
         
   /*----------------------------------------------------------------------
    
    
    PROM Support
    
    
    ----------------------------------------------------------------------*/

   reg [PROM_AW+1:0]   prom_wb_addr, prom_wb_addr_nxt;
   reg [17:0] 	       prom_wb_instr, prom_wb_instr_nxt;
   reg [2:0] 	       prom_wb_state, prom_wb_state_nxt;
   generate
      
      if ((CFG_ROM_EN == 1) && (I_CFG_XIP == 1)) begin
	 
	 // PROM is external and it can only be accessed via the WISHBONE. 
	 
	 always @(/*AUTOSENSE*/I_ACK_I or I_CYC_O or prom_enable
		  or prom_wb_state)
	   casez (prom_wb_state)
	     3'b000: prom_wb_state_nxt = prom_enable ? 3'b001 : prom_wb_state;
	     3'b001: prom_wb_state_nxt = 3'b010;
	     3'b010: prom_wb_state_nxt = (I_CYC_O & I_ACK_I) ? 3'b011 : prom_wb_state;
	     3'b011: prom_wb_state_nxt = 3'b100;
	     3'b100: prom_wb_state_nxt = (I_CYC_O & I_ACK_I) ? 3'b101 : prom_wb_state;
	     3'b101: prom_wb_state_nxt = 3'b110;
	     3'b110: prom_wb_state_nxt = (I_CYC_O & I_ACK_I) ? 3'b111 : prom_wb_state;
	     3'b111: prom_wb_state_nxt = 3'b000;
	     default:
	       prom_wb_state_nxt = 3'b000;
	   endcase
	 
	 always @(/*AUTOSENSE*/I_ACK_I or I_DAT_I or prom_wb_addr
		  or prom_wb_instr or prom_wb_state)
	   if ((prom_wb_state == 3'b010) 
	       || (prom_wb_state == 3'b100) 
	       || (prom_wb_state == 3'b110))
	     begin
		I_CYC_O  = 1'b1;
		I_STB_O  = 1'b1;
		I_ADR_O  = CFG_ROM_BASE_ADDRESS | prom_wb_addr;
		I_DAT_O  = 8'b0;
		I_SEL_O  = 1'b1;
		I_CTI_O  = 3'b000;
		I_BTE_O  = 2'b00;
		I_WE_O   = 1'b0;
		I_LOCK_O = 1'b0;
		if (I_ACK_I)
`ifdef LITTLE_ENDIAN
		  if (prom_wb_state == 3'b010)
		    prom_wb_instr_nxt = {prom_wb_instr[17:8], I_DAT_I};
		  else if (prom_wb_state == 3'b100)
		    prom_wb_instr_nxt = {prom_wb_instr[17:16], I_DAT_I, prom_wb_instr[7:0]};
		  else if (prom_wb_state == 3'b110)
		    prom_wb_instr_nxt = {I_DAT_I[1:0], prom_wb_instr[15:0]};
		  else
		    prom_wb_instr_nxt = prom_wb_instr;
`else
		  if (prom_wb_state == 3'b010)
		    prom_wb_instr_nxt = {I_DAT_I[1:0], prom_wb_instr[15:0]};
		  else if (prom_wb_state == 3'b100)
		    prom_wb_instr_nxt = {prom_wb_instr[17:16], I_DAT_I, prom_wb_instr[7:0]};
		  else if (prom_wb_state == 3'b110)
		    prom_wb_instr_nxt = {prom_wb_instr[17:8], I_DAT_I};
		  else
		    prom_wb_instr_nxt = prom_wb_instr;
`endif
		else
		  prom_wb_instr_nxt = prom_wb_instr;
	     end
	   else 
	     begin
		I_CYC_O  = 1'b0;
		I_STB_O  = 1'b0;
		I_ADR_O  = 32'b0;
		I_DAT_O  = 8'b0;
		I_SEL_O  = 1'b0;
		I_CTI_O  = 3'b000;
		I_BTE_O  = 2'b00;
		I_WE_O   = 1'b0;
		I_LOCK_O = 1'b0;
		prom_wb_instr_nxt = prom_wb_instr;
	     end
	 
	 always @(/*AUTOSENSE*/I_ACK_I or prom_addr or prom_enable
		  or prom_wb_addr or prom_wb_state)
	   if ((prom_wb_state == 3'b000) && prom_enable)
	     prom_wb_addr_nxt = {1'b0, prom_addr, 1'b0} + {2'b00, prom_addr};
	   else if (I_ACK_I 
		    && ((prom_wb_state == 3'b010) || (prom_wb_state == 3'b100)))
	     prom_wb_addr_nxt = prom_wb_addr + 1'b1;
	   else
	     prom_wb_addr_nxt = prom_wb_addr;
	 
	 assign prom_ready = (prom_wb_state == 3'b111) ? 1'b1 : 1'b0;
	 assign instr = prom_wb_instr;
	 
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     begin
		prom_wb_state <= #1 3'b000;
		prom_wb_addr <= #1 'b0;
		prom_wb_instr <= #1 17'b0;
	     end
	   else
	     begin
		prom_wb_state <= #1 prom_wb_state_nxt;
		prom_wb_addr <= #1 prom_wb_addr_nxt;
		prom_wb_instr <= #1 prom_wb_instr_nxt;
	     end
	 
      end
      else if ((CFG_ROM_EN == 1) && (I_CFG_XIP == 0)) begin
	 
	 // Instantiate the internal PROM as a Single-Port RAM because it
	 // will be updated with the contents of an external ROM.
	 
	 pmi_ram_dq
	   #(
	     .pmi_addr_depth       (CFG_PROM_SIZE),
	     .pmi_addr_width       (PROM_AW),
	     .pmi_data_width       (18),
	     .pmi_regmode          ("noreg"),
	     .pmi_gsr              ("disable"),
	     .pmi_resetmode        ("async"),
	     .pmi_init_file        (CFG_PROM_INIT_FILE),
	     .pmi_init_file_format (CFG_PROM_INIT_FILE_FORMAT),
	     .pmi_family           (LATTICE_FAMILY),
	     .module_type          ("pmi_ram_dq")
	     ) u1_isp8_prom
	     (
	      .Address (prom_wren ? prom_waddr[PROM_AW-1+2:2] : prom_addr[PROM_AW-1:0]),
	      .Data    (prom_wdata),
	      .Clock   (clk_i),
	      .ClockEn (prom_enable || prom_wren),
	      .WE      (prom_wren),
	      .Reset   (1'b0),
	      .Q       (instr)
	      );
	 assign prom_ready = 1'b1;
	 
      end
      else begin
	 
	 wire [17:0] instr_mem_out;
	 reg 	     first_fetch, first_fetch_nxt;
	 
	 pmi_ram_dq
	   #(
	     .pmi_addr_depth       (CFG_PROM_SIZE),
	     .pmi_addr_width       (PROM_AW),
	     .pmi_data_width       (18),
	     .pmi_regmode          ("noreg"),
	     .pmi_gsr              ("disable"),
	     .pmi_resetmode        ("async"),
	     .pmi_init_file        (CFG_PROM_INIT_FILE),
	     .pmi_init_file_format (CFG_PROM_INIT_FILE_FORMAT),
	     .pmi_family           (LATTICE_FAMILY),
	     .module_type          ("pmi_ram_dq")
	     ) u1_isp8_prom
	     (
	      .Address (prom_addr[PROM_AW-1:0]),
	      .Data    (18'b0),
	      .Clock   (clk_i),
	      .ClockEn (prom_enable),
	      .WE      (1'b0),
	      .Reset   (1'b0),
	      .Q       (instr_mem_out)
	      );
	 assign instr = first_fetch ? instr_mem_out : 18'b0;
	 assign prom_ready = first_fetch ? 1'b1 : 1'b0;
	 
	 always @(posedge clk_i or negedge core_rst_n)
	   begin
	      if (core_rst_n == 1'b0)
		first_fetch <= #1 1'b0;
	      else
		if (first_fetch == 1'b0)
		  first_fetch <= #1 prom_enable;
	   end
   
      end
      
   endgenerate
   
   /*----------------------------------------------------------------------
    
    
    Scratchpad and I/O Support
    
    
    ----------------------------------------------------------------------*/
   wire [7:0] internal_sp_dout;
   wire       ext_wr, ext_cyc, external_sp;
   reg [7:0]  ext_din;
   reg [7:0]  save_data, save_data_nxt;
   reg [31:0] sp_rd_addr, sp_rd_addr_nxt;
   reg 	      ext_ready;
   reg 	      ext_wb_state, ext_wb_state_nxt;
   
   generate
      
      if (CFG_ROM_EN == 1) begin
	 
	 // The I/O WISHBONE interface is also used at boot to (optionally)
	 // load the PROM and Scratchpad from external ROM. This interface
	 // also manages the writes to external PROM and Scratchpad for the
	 // purpose of loading the image from ROM.
	 
	 always @(/*AUTOSENSE*/D_ACK_I or ext_cyc or ext_wb_state
		  or prom_rden or sp_rden or sp_wb_wren)
	   if (((ext_wb_state == 1'b0) 
		&& (ext_cyc || sp_wb_wren || prom_rden || sp_rden))
	       || (ext_wb_state && (D_ACK_I == 0)))
	     ext_wb_state_nxt = 1'b1;
	   else
	     ext_wb_state_nxt = 1'b0;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or ext_addr or ext_cyc
		  or ext_dout or ext_io_rd or ext_io_wr
		  or ext_wb_state or ext_wr or prom_raddr or prom_rden
		  or sp_rd_addr or sp_rden or sp_waddr or sp_wb_wren
		  or sp_wdata)
	   begin
	      if (ext_cyc || prom_rden || sp_wb_wren || sp_rden || ext_wb_state)
		begin
		   D_CYC_O  = 1'b1;
		   D_STB_O  = 1'b1;
		   
		   if (prom_rden)
		     D_ADR_O = ALIGN_PROM_ROM_BASE | {{(32 - PROM_AW - 2){1'b0}}, prom_raddr};
		   else if (sp_wb_wren)
		     D_ADR_O = ALIGN_SP_BASE | {{(32 - CFG_EXT_SIZE){1'b0}}, sp_waddr};
		   else if (sp_rden)
		     D_ADR_O = sp_rd_addr;
		   else if (ext_io_rd || ext_io_wr)
		     D_ADR_O = ALIGN_IO_BASE | {{(32 - CFG_EXT_SIZE){1'b0}}, ext_addr};
		   else
		     D_ADR_O = ALIGN_SP_BASE | {{(32 - CFG_EXT_SIZE){1'b0}}, ext_addr};
		   
		   if (sp_wb_wren)
		     D_DAT_O = sp_wdata[7:0];
		   else
		     D_DAT_O  = ext_dout;
		   D_SEL_O  = 1'b1;
		   D_CTI_O  = 3'b000;
		   D_BTE_O  = 2'b00;
		   D_WE_O   = ext_wr | sp_wb_wren;
		   D_LOCK_O = 1'b0;
		end
	      else
		begin
		   D_CYC_O  = 1'b0;
		   D_STB_O  = 1'b0;
		   D_ADR_O  = 32'b0;
		   D_DAT_O  = ext_dout;
		   D_SEL_O  = 1'b0;
		   D_CTI_O  = 3'b000;
		   D_BTE_O  = 2'b00;
		   D_WE_O   = 1'b0;
		   D_LOCK_O = 1'b0;
		end
	      
	      if (ext_wb_state
		  && !(prom_rden || sp_wb_wren || sp_rden))
		ext_ready = D_ACK_I;
	      else
		ext_ready = 1'b0;
	   end
	 
      end
      else begin

	 reg D_ACK_I_d;
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     D_ACK_I_d <= #1 1'b0;
	   else
	     D_ACK_I_d <= #1 D_ACK_I;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_ACK_I_d or ext_cyc
		  or ext_wb_state)
	   if ((D_ACK_I_d == 1'b0)
	       && ((ext_cyc && (ext_wb_state == 1'b0)) || (ext_wb_state && (D_ACK_I == 0))))
	     ext_wb_state_nxt = 1'b1;
	   else
	     ext_wb_state_nxt = 1'b0;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or ext_addr or ext_cyc
		  or ext_dout or ext_io_rd or ext_io_wr
		  or ext_wb_state or ext_wr)
	   begin
	      if (ext_cyc || ext_wb_state)
		begin
		   D_CYC_O  = 1'b1;
		   D_STB_O  = 1'b1;
		   if (ext_io_rd || ext_io_wr)
		     D_ADR_O = ALIGN_IO_BASE | {{(32 - CFG_EXT_SIZE){1'b0}}, ext_addr};
		   else
		     D_ADR_O = ALIGN_SP_BASE | {{(32 - CFG_EXT_SIZE){1'b0}}, ext_addr};
		   D_DAT_O  = ext_dout;
		   D_SEL_O  = 1'b1;
		   D_CTI_O  = 3'b000;
		   D_BTE_O  = 2'b00;
		   D_WE_O   = ext_wr;
		   D_LOCK_O = 1'b0;
		end
	      else
		begin
		   D_CYC_O  = 1'b0;
		   D_STB_O  = 1'b0;
		   D_ADR_O  = 32'b0;
		   D_DAT_O  = ext_dout;
		   D_SEL_O  = 1'b0;
		   D_CTI_O  = 3'b000;
		   D_BTE_O  = 2'b00;
		   D_WE_O   = 1'b0;
		   D_LOCK_O = 1'b0;
		end
	      
	      if (ext_wb_state)
		ext_ready = D_ACK_I;
	      else
		ext_ready = 1'b0;
	   end
	 
      end
      
   endgenerate
   
   always @(D_ACK_I or save_data or D_DAT_I)
     if (D_ACK_I)
       save_data_nxt = D_DAT_I;
     else
       save_data_nxt = save_data;
   
   assign ext_io_din = ext_wb_state ? D_DAT_I : save_data;
   
   generate
      
      if (SP_PORT_ENABLE == 0) begin
	 
	 assign ext_cyc = ext_addr_cyc;
	 assign ext_wr = ext_io_wr | ext_mem_wr;
	 assign ext_mem_din = ext_io_din;
	 assign ext_mem_ready = ext_ready;
	 
      end
      else begin
	 
	 if (CFG_EXT_SIZE <= SP_AW) begin
	    
	    assign external_sp = 1'b0;
	    assign ext_cyc = ((ext_io_rd | ext_io_wr) 
			      ? ext_addr_cyc 
			      : 1'b0);
	    assign ext_wr = ext_io_wr;
	    assign ext_mem_ready = ((ext_io_rd | ext_io_wr) 
				    ? ext_ready 
				    : (ext_mem_rd | ext_mem_wr) ? 1'b1 : 1'b0);
	    assign ext_mem_din = internal_sp_dout;
	 end
	 else begin
	    
	    assign external_sp = ext_addr[CFG_EXT_SIZE-1:SP_AW] != INTERNAL_SP_CHECK;
	    assign ext_cyc = ((ext_io_rd | ext_io_wr) 
			      ? ext_addr_cyc 
			      : (ext_mem_rd | ext_mem_wr) & external_sp);
	    assign ext_wr = ext_io_wr | ext_mem_wr;
	    assign ext_mem_ready = ((ext_io_rd | ext_io_wr) 
				    ? ext_ready 
				    : ((ext_mem_rd | ext_mem_wr) 
				       ? (external_sp ? ext_ready : 1'b1)
				       : 1'b0));
	    assign ext_mem_din = external_sp ? ext_io_din : internal_sp_dout;
	 end
	 
	 pmi_ram_dq
	   #(
	     .pmi_addr_depth       (SP_SIZE),
	     .pmi_addr_width       (SP_AW),
	     .pmi_data_width       (8),
	     .pmi_regmode          ("noreg"),
	     .pmi_gsr              ("disable"),
	     .pmi_resetmode        ("async"),
	     .pmi_init_file        (CFG_SP_INIT_FILE),
	     .pmi_init_file_format (CFG_SP_INIT_FILE_FORMAT),
	     .pmi_family           (LATTICE_FAMILY),
	     .module_type          ("pmi_ram_dq")
	     ) u1_scratchpad
	     (
	      // Outputs
	      .Q		(internal_sp_dout),
	      // Inputs
	      .Data		(sp_wren ? sp_wdata : ext_dout),
	      .Address	        (sp_wren ? sp_waddr[SP_AW-1:0] : ext_addr[SP_AW-1:0]),
	      .Clock		(clk_i),
	      .ClockEn	        (1'b1),
	      .WE		((ext_mem_wr | sp_wren) & ~external_sp),
	      .Reset		(1'b0));
	 
      end
      
   endgenerate
   
   always @(posedge clk_i)
     if (rst_n == 1'b0)
       begin
	  ext_wb_state <= #1 1'b0;
	  save_data <= #1 8'b0;
       end
     else
       begin
	  ext_wb_state <= #1 ext_wb_state_nxt;
	  save_data <= #1 save_data_nxt;
       end
   
   /*----------------------------------------------------------------------
    
    
    Logic that manages loading of PROM and Scratchpad from external ROM
    
    
    ----------------------------------------------------------------------*/
   
   wire prom_copy_start, sp_copy_start, core_start;
   reg 	prom_copy_done, prom_copy_done_nxt;
   reg 	sp_copy_done, sp_copy_done_nxt;
   
   generate

      if ((CFG_ROM_EN == 1) && (I_CFG_XIP == 0)) begin
	 
	 reg [1:0] rom_state, rom_state_nxt;
	 
	 always @(/*AUTOSENSE*/prom_copy_done or rom_state
		  or sp_copy_done)
	   begin
	      casez (rom_state)
		2'b00: rom_state_nxt = 2'b01;
		2'b01: rom_state_nxt = prom_copy_done ? 2'b10 : rom_state;
		2'b10: rom_state_nxt = sp_copy_done ? 2'b11 : rom_state;
		2'b11: rom_state_nxt = rom_state;
		default:
		  rom_state_nxt = 2'b00;
	      endcase
	   end
	 
	 assign prom_copy_start = (rom_state == 2'b01) ? 1'b1 : 1'b0;
	 assign sp_copy_start = (rom_state == 2'b10) ? 1'b1 : 1'b0;
	 assign core_start = (rom_state == 2'b11) ? 1'b1 : 1'b0;
	 	 
	 always @(posedge clk_i)
	   begin
	      if (rst_n == 1'b0)
		rom_state <= #1 2'b00;
	      else
		rom_state <= #1 rom_state_nxt;
	   end
	 
      end
      else if ((CFG_ROM_EN == 1) && (I_CFG_XIP == 1)) begin
	 
	 reg [1:0] rom_state, rom_state_nxt;
	 	 
	 always @(/*AUTOSENSE*/rom_state or sp_copy_done)
	   begin
	      casez (rom_state)
		2'b00: rom_state_nxt = 2'b10;
		2'b10: rom_state_nxt = sp_copy_done ? 2'b11 : rom_state;
		2'b11: rom_state_nxt = rom_state;
		default:
		  rom_state_nxt = 2'b00;
	      endcase
	   end
	 
	 assign prom_copy_start = 1'b0;
	 assign sp_copy_start = (rom_state == 2'b10) ? 1'b1 : 1'b0;
	 assign core_start = (rom_state == 2'b11) ? 1'b1 : 1'b0;
	 	 
	 always @(posedge clk_i)
	   begin
	      if (rst_n == 1'b0)
		rom_state <= #1 2'b00;
	      else
		rom_state <= #1 rom_state_nxt;
	   end
	 
      end
      else begin
	 
	 assign prom_copy_start = 1'b0;
	 assign sp_copy_start = 1'b0;
	 	 	 	 
      end
      
   endgenerate

   /*----------------------------------------------------------------------
    
    
    Core Reset Logic
    
    
    ----------------------------------------------------------------------*/
   
   generate
      
      if (CFG_ROM_EN == 1) begin
	 
	 // The core's reset is released only after the PROM and Scratchpad
	 // have been loaded from external ROM
	 
	 reg rst_n_dly;
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     rst_n_dly <= #1 1'b0;
	   else
	     rst_n_dly <= #1 (rst_n & core_start);
	 
	 assign core_rst_n = rst_n_dly;
	 	 
      end
      else begin
	 
	 assign core_rst_n = rst_n;
	 
      end
      
   endgenerate
   
   /*----------------------------------------------------------------------
    
    
    Logic that loads PROM from external ROM
    
    
    ----------------------------------------------------------------------*/
   
   generate
      
      if ((CFG_ROM_EN == 1) && (I_CFG_XIP == 0)) begin
	 
	 reg [PROM_AW+2:0] prom_rd_cnt, prom_rd_cnt_nxt;
	 reg [PROM_AW:0]   prom_wr_cnt, prom_wr_cnt_nxt;
	 reg [17:0] 	   prom_entry, prom_entry_nxt;
	 reg [1:0] 	   prom_copy_state, prom_copy_state_nxt;
	 reg [1:0] 	   prom_byte_cnt, prom_byte_cnt_nxt;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or prom_copy_done
		  or prom_copy_start or prom_copy_state)
	   casez (prom_copy_state)
	     2'b00:
	       if (prom_copy_start && (prom_copy_done != 1'b1))
		 prom_copy_state_nxt = 2'b01;
	       else
		 prom_copy_state_nxt = prom_copy_state;
	     2'b01:
	       if (D_ACK_I)
		 prom_copy_state_nxt = 2'b10;
	       else
		 prom_copy_state_nxt = prom_copy_state;
	     default:
	       prom_copy_state_nxt = 2'b00;
	   endcase
	 
	 always @(/*AUTOSENSE*/prom_byte_cnt or prom_copy_state)
	   begin
	      if (prom_copy_state == 2'b10)
		casez (prom_byte_cnt)
		  2'b00: prom_byte_cnt_nxt = 2'b01;
		  2'b01: prom_byte_cnt_nxt = 2'b10;
		  default:
		    prom_byte_cnt_nxt = 2'b00;
		endcase
	      else
		prom_byte_cnt_nxt = prom_byte_cnt;
	   end
	      
	 always @(/*AUTOSENSE*/prom_copy_state or prom_rd_cnt)
	   if (prom_copy_state == 2'b10)
	     prom_rd_cnt_nxt = prom_rd_cnt + 1'b1;
	   else
	     prom_rd_cnt_nxt = prom_rd_cnt;

	 always @(/*AUTOSENSE*/prom_byte_cnt or prom_copy_state
		  or prom_wr_cnt)
	   if ((prom_copy_state == 2'b10) && (prom_byte_cnt == 2'b10))
	     prom_wr_cnt_nxt = prom_wr_cnt + 1'b1;
	   else
	     prom_wr_cnt_nxt = prom_wr_cnt;
	 
	 always @(/*AUTOSENSE*/prom_copy_state or prom_rd_cnt)
	   if ((prom_copy_state == 2'b10) && (prom_rd_cnt == (CFG_PROM_SIZE*3)-1))
	     prom_copy_done_nxt = 1'b1;
	   else
	     prom_copy_done_nxt = 1'b0;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or D_DAT_I
		  or prom_byte_cnt or prom_copy_state or prom_entry)
	   if ((prom_copy_state == 2'b01) && D_CYC_O && D_ACK_I)
	     begin
`ifdef LITTLE_ENDIAN
		if (prom_byte_cnt == 2'b00)
		  prom_entry_nxt[7:0] = D_DAT_I;
		else
		  prom_entry_nxt[7:0] = prom_entry[7:0];
		
		if (prom_byte_cnt == 2'b01)
		  prom_entry_nxt[15:8] = D_DAT_I;
		else
		  prom_entry_nxt[15:8] = prom_entry[15:8];
		
		if (prom_byte_cnt == 2'b10)
		  prom_entry_nxt[17:16] = D_DAT_I[1:0];
		else
		  prom_entry_nxt[17:16] = prom_entry_nxt[17:16];
`else
		if (prom_byte_cnt == 2'b00)
		  prom_entry_nxt[17:16] = D_DAT_I[1:0];
		else
		  prom_entry_nxt[17:16] = prom_entry[17:16];
		
		if (prom_byte_cnt == 2'b01)
		  prom_entry_nxt[15:8] = D_DAT_I;
		else
		  prom_entry_nxt[15:8] = prom_entry[15:8];
		
		if (prom_byte_cnt == 2'b10)
		  prom_entry_nxt[7:0] = D_DAT_I;
		else
		  prom_entry_nxt[7:0] = prom_entry[7:0];
`endif
	     end
	   else
	     prom_entry_nxt = prom_entry;
	 
	 always @(/*AUTOSENSE*/prom_byte_cnt or prom_copy_state
		  or prom_entry or prom_rd_cnt or prom_wr_cnt)
	   begin
`ifndef FLASH_SIMULATION
	      prom_raddr = prom_rd_cnt[PROM_AW+2-1:0];
`else
	      prom_raddr = {prom_wr_cnt[PROM_AW-1:0], prom_byte_cnt};
`endif
	      if (prom_copy_state == 2'b01)
		prom_rden = 1'b1;
	      else
		prom_rden = 1'b0;
	      
	      prom_waddr = {prom_wr_cnt[PROM_AW-1:0], 2'b00};
	      prom_wdata = prom_entry;
	      if ((prom_copy_state == 2'b10) && (prom_byte_cnt == 2'b10))
		prom_wren  = 1'b1;
	      else
		prom_wren  = 1'b0;
	   end
	 
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     begin
		prom_rd_cnt <= #1 0;
		prom_wr_cnt <= #1 0;
		prom_entry <= #1 18'b0;
		prom_copy_state <= #1 2'b00;
		prom_byte_cnt <= #1 2'b00;
		prom_copy_done <= #1 1'b0;
	     end
	   else
	     begin
		prom_rd_cnt <= #1 prom_rd_cnt_nxt;
		prom_wr_cnt <= #1 prom_wr_cnt_nxt;
		prom_entry <= #1 prom_entry_nxt;
		prom_copy_state <= #1 prom_copy_state_nxt;
		prom_byte_cnt <= #1 prom_byte_cnt_nxt;
		prom_copy_done <= #1 prom_copy_done_nxt;
	     end
	 
      end
      else begin
	 
	 always @(clk_i)
	   begin
	      prom_wren = 1'b0;
	      prom_rden = 1'b0;
	   end
	 
      end
      
   endgenerate
   
   /*----------------------------------------------------------------------
    
    
    Logic that loads Scratchpad from external ROM
    
    
    ----------------------------------------------------------------------*/
   
   generate
      
      if ((CFG_ROM_EN == 1) && (SP_PORT_ENABLE == 0)) begin

	 reg [SP_AW:0] sp_rd_cnt, sp_rd_cnt_nxt;
	 reg [7:0]     sp_entry, sp_entry_nxt;
	 reg [1:0]     sp_copy_state, sp_copy_state_nxt;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or sp_copy_done
		  or sp_copy_start or sp_copy_state)
	   casez (sp_copy_state)
	     2'b00:
	       if (sp_copy_start && (sp_copy_done != 1'b1))
		 sp_copy_state_nxt = 2'b01;
	       else
		 sp_copy_state_nxt = 2'b00;
	     2'b01:
	       if (D_ACK_I)
		 sp_copy_state_nxt = 2'b10;
	       else
		 sp_copy_state_nxt = sp_copy_state;
	     2'b10:
	       sp_copy_state_nxt = 2'b11;
	     2'b11:
	       if (D_ACK_I)
		 sp_copy_state_nxt = 2'b00;
	       else
		 sp_copy_state_nxt = sp_copy_state;
	     default:
	       sp_copy_state_nxt = 2'b00;
	   endcase
	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or sp_copy_state
		  or sp_rd_cnt)
	   if ((sp_copy_state == 2'b11) && D_CYC_O && D_ACK_I)
	     sp_rd_cnt_nxt = sp_rd_cnt + 1'b1;
	   else
	     sp_rd_cnt_nxt = sp_rd_cnt;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or sp_copy_state
		  or sp_rd_addr)
	   if ((sp_copy_state == 2'b11) && D_CYC_O && D_ACK_I)
	     sp_rd_addr_nxt = sp_rd_addr + 1'b1;
	   else
	     sp_rd_addr_nxt = sp_rd_addr;
	 	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or sp_copy_state
		  or sp_rd_cnt)
	   if ((sp_copy_state == 2'b11) && (sp_rd_cnt == SP_SIZE-1) && D_CYC_O && D_ACK_I)
	     sp_copy_done_nxt = 1'b1;
	   else
	     sp_copy_done_nxt = 1'b0;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or D_DAT_I
		  or sp_copy_state or sp_entry)
	   if ((sp_copy_state == 2'b01) && D_CYC_O && D_ACK_I)
	     sp_entry_nxt = D_DAT_I;
	   else
	     sp_entry_nxt = sp_entry;
	 
	 always @(/*AUTOSENSE*/sp_copy_state or sp_entry or sp_rd_cnt)
	   begin
	      sp_raddr = sp_rd_cnt;
	      if (sp_copy_state == 2'b01)
		sp_rden = 1'b1;
	      else
		sp_rden = 1'b0;
	      
	      sp_waddr = sp_rd_cnt;
	      sp_wdata = sp_entry;
	      if (sp_copy_state == 2'b11)
		sp_wb_wren = 1'b1;
	      else
		sp_wb_wren = 1'b0;
	      sp_wren = 1'b0;
	   end
	 
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     begin
		sp_rd_cnt <= #1 0;
		sp_entry <= #1 8'b0;
		sp_copy_state <= #1 2'b00;
		sp_copy_done <= #1 1'b0;
		sp_rd_addr <= #1 ALIGN_SP_ROM_BASE;
	     end
	   else
	     begin
		sp_rd_cnt <= #1 sp_rd_cnt_nxt;
		sp_entry <= #1 sp_entry_nxt;
		sp_copy_state <= #1 sp_copy_state_nxt;
		sp_copy_done <= #1 sp_copy_done_nxt;
		sp_rd_addr <= #1 sp_rd_addr_nxt;
	     end
	 
      end
      
      else if ((CFG_ROM_EN == 1) && (SP_PORT_ENABLE == 1)) begin
	 
	 reg [SP_AW:0] sp_rd_cnt, sp_rd_cnt_nxt;
	 reg [7:0]     sp_entry, sp_entry_nxt;
	 reg [1:0]     sp_copy_state, sp_copy_state_nxt;
	 
	 always @(/*AUTOSENSE*/D_ACK_I or sp_copy_done
		  or sp_copy_start or sp_copy_state)
	   casez (sp_copy_state)
	     2'b00:
	       if (sp_copy_start && (sp_copy_done != 1'b1))
		 sp_copy_state_nxt = 2'b01;
	       else
		 sp_copy_state_nxt = sp_copy_state;
	     2'b01:
	       if (D_ACK_I)
		 sp_copy_state_nxt = 2'b10;
	       else
		 sp_copy_state_nxt = sp_copy_state;
	     default:
	       sp_copy_state_nxt = 2'b00;
	   endcase
	 
	 always @(/*AUTOSENSE*/sp_copy_state or sp_rd_cnt)
	   if (sp_copy_state == 2'b10)
	     sp_rd_cnt_nxt = sp_rd_cnt + 1'b1;
	   else
	     sp_rd_cnt_nxt = sp_rd_cnt;
	 
	 always @(/*AUTOSENSE*/sp_copy_state or sp_rd_addr)
	   if (sp_copy_state == 2'b10)
	     sp_rd_addr_nxt = sp_rd_addr + 1'b1;
	   else
	     sp_rd_addr_nxt = sp_rd_addr;
	 	 
	 always @(/*AUTOSENSE*/sp_copy_state or sp_rd_cnt)
	   if ((sp_copy_state == 2'b10) && (sp_rd_cnt == SP_SIZE-1))
	     sp_copy_done_nxt = 1'b1;
	   else
	     sp_copy_done_nxt = 1'b0;
	   
	 always @(/*AUTOSENSE*/D_ACK_I or D_CYC_O or D_DAT_I
		  or sp_copy_state or sp_entry)
	   if ((sp_copy_state == 2'b01) && D_CYC_O && D_ACK_I)
	     sp_entry_nxt = D_DAT_I;
	   else
	     sp_entry_nxt = sp_entry;
	 
	 always @(/*AUTOSENSE*/sp_copy_state or sp_entry or sp_rd_cnt)
	   begin
	      sp_raddr = sp_rd_cnt;
	      if (sp_copy_state == 2'b01)
		sp_rden = 1'b1;
	      else
		sp_rden = 1'b0;
	      
	      sp_waddr = sp_rd_cnt;
	      sp_wdata = sp_entry;
	      if (sp_copy_state == 2'b10)
		sp_wren  = 1'b1;
	      else
	     	sp_wren  = 1'b0;
	      sp_wb_wren = 1'b0;
	   end
	 
	 always @(posedge clk_i)
	   if (rst_n == 1'b0)
	     begin
		sp_rd_cnt <= #1 0;
		sp_entry <= #1 8'b0;
		sp_copy_state <= #1 2'b00;
		sp_copy_done <= #1 1'b0;
		sp_rd_addr <= #1 ALIGN_SP_ROM_BASE;
	     end
	   else
	     begin
		sp_rd_cnt <= #1 sp_rd_cnt_nxt;
		sp_entry <= #1 sp_entry_nxt;
		sp_copy_state <= #1 sp_copy_state_nxt;
		sp_copy_done <= #1 sp_copy_done_nxt;
		sp_rd_addr <= #1 sp_rd_addr_nxt;
	     end
	 
      end
      else if (CFG_ROM_EN == 0) begin
	 
	 always @(clk_i)
	   begin
	      sp_wren = 1'b0;
	      sp_wb_wren = 1'b0;
	      sp_rden = 1'b0;
	   end
	 
      end
      
   endgenerate
   
   function integer clogb2;
      input [31:0] value;
      reg   [31:0] i;
      reg   [31:0] temp;
      begin
	 temp = 0;
	 i    = 0;
	 
	 for (i = 0; temp < value; i = i + 1)  
	   temp = 1 << i;
	 
	 clogb2 = i - 1;
      end
   endfunction
   
endmodule
